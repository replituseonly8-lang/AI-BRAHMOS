import requests
import config
import io
from utils import AnimatedLoader

def generate_tts(text, voice="nova", bot=None, chat_id=None):
    """Generate TTS using ReflexAI endpoint"""
    loader = None
    
    try:
        # Start animated loading if bot and chat_id provided
        if bot and chat_id:
            loader = AnimatedLoader(bot, chat_id, "Converting to speech", "tts")
            loader.start()
            
        print(f"[DEBUG] Generating TTS with voice: {voice}")
        
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {config.API_KEY}"
        }
        
        payload = {
            "model": config.TTS_MODEL,
            "input": text,
            "voice": voice,
            "response_format": "mp3",
            "speed": 1.0
        }
        
        print(f"[DEBUG] Sending TTS request to: {config.TTS_API_ENDPOINT}")
        response = requests.post(
            config.TTS_API_ENDPOINT,
            json=payload,
            headers=headers,
            timeout=60
        )
        
        print(f"[DEBUG] TTS response: {response.status_code}")
        
        if response.status_code == 200:
            content_type = response.headers.get('Content-Type', '').lower()
            print(f"[DEBUG] TTS Content-Type: {content_type}")
            
            # Check if response is audio
            if content_type.startswith('audio/') or len(response.content) > 1000:
                print(f"[DEBUG] TTS success: Audio received ({len(response.content)} bytes)")
                return response.content
            else:
                print(f"[DEBUG] TTS returned non-audio data: {content_type}")
                return None
        else:
            print(f"[DEBUG] TTS failed with status: {response.status_code}")
            return None
            
    except requests.exceptions.Timeout:
        print("[DEBUG] TTS generation timeout")
        return None
    except requests.exceptions.ConnectionError:
        print("[DEBUG] TTS generation connection error")
        return None
    except Exception as e:
        print(f"[DEBUG] TTS generation error: {e}")
        return None
    finally:
        # Stop the loader
        if loader:
            loader.stop()

def handle_say_command(bot, message, usage_tracker):
    """Handle /say command with usage tracking"""
    from utils import log_user_interaction, is_premium_user
    
    user_id = message.from_user.id
    log_user_interaction(message.from_user, "/say", "DM" if message.chat.type == "private" else "Group")
    
    # Check if user provided text
    text_input = message.text.strip()
    if len(text_input.split()) <= 1:
        bot.reply_to(message, """🎤 **Text-to-Speech Help**

**Usage:** `/say [text]`

**Examples:**
• `/say Hello, how are you today?`
• `/say Welcome to BrahMos AI!`
• `/say This is a test of speech synthesis`

**🎵 Available Voices:** alloy, echo, fable, onyx, nova, shimmer

**💡 Tip:** Keep text under 500 characters for best results!""", parse_mode="Markdown")
        return

    # Extract text (remove "/say ")
    text_to_speak = text_input[4:].strip()
    
    # Validate text length
    if len(text_to_speak) > 500:
        bot.reply_to(message, "❌ **Text too long!** Please keep your text under 500 characters.", parse_mode="Markdown")
        return
    
    # Check usage limits for free users
    if not is_premium_user(user_id):
        if not usage_tracker.can_use_tts(user_id):
            bot.reply_to(message, """🚫 **Daily TTS Limit Reached**

You've used all 100 free TTS generations for today!

💎 **Upgrade to Premium for:**
• Unlimited TTS generations
• All voice options
• Priority processing

Contact @Rystrix to upgrade!""", parse_mode="Markdown")
            return
        
        # Warning when approaching limit
        remaining = usage_tracker.get_remaining_tts(user_id)
        if remaining <= 10:
            bot.reply_to(message, f"⚠️ **Usage Warning:** Only {remaining} TTS generations left today!", parse_mode="Markdown")

    try:
        # Generate TTS
        audio_data = generate_tts(text_to_speak, "nova", bot, message.chat.id)
        
        if audio_data:
            # Track usage for free users
            if not is_premium_user(user_id):
                usage_tracker.use_tts(user_id)
                remaining = usage_tracker.get_remaining_tts(user_id)
                remaining_text = f"\n\n📊 **Remaining today:** {remaining}/100"
            else:
                remaining_text = "\n\n💎 **Premium User - Unlimited Access!**"
            
            caption = f"🎤 **Text-to-Speech**\n\n**Text:** `{text_to_speak}`\n**Voice:** Nova\n\n✨ **Generated by BrahMos AI**{remaining_text}"
            
            # Send the audio
            bot.send_voice(
                message.chat.id,
                io.BytesIO(audio_data),
                caption=caption,
                parse_mode="Markdown",
                reply_to_message_id=message.message_id
            )
        else:
            bot.reply_to(message, "❌ **TTS Generation Failed**\n\nSorry, I couldn't convert your text to speech. Please try again.", parse_mode="Markdown")
            
    except Exception as e:
        print(f"[DEBUG] TTS error: {e}")
        bot.reply_to(message, "💥 **Error:** Something went wrong while generating speech. Please try again!")

def handle_tts_input(bot, message, user_waiting_for_tts, usage_tracker):
    """Handle TTS text input when user is in TTS waiting mode"""
    from utils import is_premium_user
    
    user_id = message.from_user.id
    
    if user_id in user_waiting_for_tts:
        user_waiting_for_tts.remove(user_id)
        
        # Use the message text for TTS
        text_to_speak = message.text.strip()
        
        # Validate text length
        if len(text_to_speak) > 500:
            bot.reply_to(message, "❌ **Text too long!** Please keep your text under 500 characters.", parse_mode="Markdown")
            return
        
        # Check usage limits for free users
        if not is_premium_user(user_id):
            if not usage_tracker.can_use_tts(user_id):
                bot.reply_to(message, """🚫 **Daily TTS Limit Reached**

You've used all 100 free TTS generations for today!

💎 **Upgrade to Premium for:**
• Unlimited TTS generations
• All voice options  
• Priority processing

Contact @Rystrix to upgrade!""", parse_mode="Markdown")
                return
        
        try:
            # Generate TTS
            audio_data = generate_tts(text_to_speak, "nova", bot, message.chat.id)
            
            if audio_data:
                # Track usage for free users
                if not is_premium_user(user_id):
                    usage_tracker.use_tts(user_id)
                    remaining = usage_tracker.get_remaining_tts(user_id)
                    remaining_text = f"\n\n📊 **Remaining today:** {remaining}/100"
                else:
                    remaining_text = "\n\n💎 **Premium User - Unlimited Access!**"
                
                caption = f"🎤 **Text-to-Speech**\n\n**Text:** `{text_to_speak}`\n**Voice:** Nova\n\n✨ **Generated by BrahMos AI**{remaining_text}"
                
                # Send the audio
                bot.send_voice(
                    message.chat.id,
                    io.BytesIO(audio_data),
                    caption=caption,
                    parse_mode="Markdown",
                    reply_to_message_id=message.message_id
                )
            else:
                bot.reply_to(message, "❌ **TTS Generation Failed**\n\nSorry, I couldn't convert your text to speech. Please try again.", parse_mode="Markdown")
                
        except Exception as e:
            print(f"[DEBUG] TTS error: {e}")
            bot.reply_to(message, "💥 **Error:** Something went wrong while generating speech. Please try again!")def handle_upgrade_premium_callback(bot, call):
    """Handle upgrade premium callback with safe text"""
    upgrade_text = """💎 **Upgrade to Premium**

🌟 **Premium Benefits:**
• ∞ Unlimited image generations
• ∞ Unlimited TTS conversions
• 🚀 Priority processing
• 🎯 Higher quality outputs
• 📞 Direct support

💰 **Contact Developer:**
Ready to upgrade? Contact @Rystrix for premium access!

Premium users get the full BrahMos AI experience without any limits."""

    keyboard = types.InlineKeyboardMarkup()
    keyboard.row(types.InlineKeyboardButton("📞 Contact Developer", url="https://t.me/Rystrix_XD"))
    keyboard.row(types.InlineKeyboardButton("🔙 Back", callback_data="back_to_start"))

    safe_edit_message(bot, call.message.chat.id, call.message.message_id, upgrade_text, keyboard, parse_mode="Markdown")

def handle_quick_chat_callback(bot, call, chat_mode, user_waiting_for_chat):
    """Handle quick chat callback"""
    user_id = call.from_user.id

    if call.message.chat.type != 'private':
        bot.answer_callback_query(call.id, "Chat mode is only available in direct messages!", show_alert=True)
        return

    chat_mode.add(user_id)
    user_waiting_for_chat.add(user_id)

    bot.answer_callback_query(call.id, "Chat mode activated! Send me a message.")
    bot.send_message(call.message.chat.id, """💬 **Chat Mode Activated!**

I'm now ready for a conversation! Just type your message and I'll respond with intelligent answers.

✨ **Features:**
• Contextual conversations
• Memory of our chat
• Smart responses
• No command needed

**What would you like to talk about?**""", parse_mode="Markdown")

def handle_quick_image_callback(bot, call, user_waiting_for_image):
    """Handle quick image callback"""
    user_id = call.from_user.id
    user_waiting_for_image.add(user_id)
    bot.answer_callback_query(call.id, "Image mode activated! Send me your prompt.")
    bot.send_message(call.message.chat.id, """🎨 **Image Generation Mode Activated!**

Send me a description of what you want to create and I'll generate an image for you.

**Examples:**
• "cyberpunk samurai warrior"
• "sunset over mountains"
• "cute cat in space suit"

💡 **Tip:** Be descriptive for better results!""", parse_mode="Markdown")

def handle_quick_tts_callback(bot, call, user_waiting_for_tts):
    """Handle quick TTS callback"""
    user_id = call.from_user.id
    user_waiting_for_tts.add(user_id)
    bot.answer_callback_query(call.id, "TTS mode activated! Send me text to convert.")
    bot.send_message(call.message.chat.id, """🎤 **Text-to-Speech Mode Activated!**

Send me any text and I'll convert it to speech for you.

**Examples:**
• "Hello, how are you today?"
• "Welcome to BrahMos AI!"
• "This is a test of speech synthesis"

💡 **Tip:** Keep text under 500 characters for best results!""", parse_mode="Markdown")

def handle_quick_edit_callback(bot, call, user_waiting_for_edit):
    """Handle quick edit callback"""
    user_id = call.from_user.id
    bot.answer_callback_query(call.id, "Edit mode ready! Use /edit [description] first.")
    bot.send_message(call.message.chat.id, """✏️ **Photo Editing Mode!**

**Step 1:** Use `/edit [description]` command
**Step 2:** Upload the photo you want to edit

**Examples:**
• `/edit make it darker and more dramatic`
• `/edit add sunglasses and a hat`  
• `/edit change background to beach`

💡 **Tip:** Be specific about what changes you want!""", parse_mode="Markdown")
