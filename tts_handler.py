import requests
import config
import io
from utils import AnimatedLoader

def generate_tts(text, voice="nova", bot=None, chat_id=None):
    """Generate TTS using ReflexAI endpoint"""
    loader = None
    
    try:
        # Start animated loading if bot and chat_id provided
        if bot and chat_id:
            loader = AnimatedLoader(bot, chat_id, "Converting to speech", "tts")
            loader.start()
            
        print(f"[DEBUG] Generating TTS with voice: {voice}")
        
        headers = {
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": config.TTS_MODEL,
            "input": text,
            "voice": voice,
            "response_format": "mp3",
            "speed": 1.0
        }
        
        print(f"[DEBUG] Sending TTS request to: {config.TTS_API_ENDPOINT}")
        response = requests.post(
            config.TTS_API_ENDPOINT,
            json=payload,
            headers=headers,
            timeout=60
        )
        
        print(f"[DEBUG] TTS response: {response.status_code}")
        
        if response.status_code == 200:
            content_type = response.headers.get('Content-Type', '').lower()
            print(f"[DEBUG] TTS Content-Type: {content_type}")
            
            # Check if response is audio
            if content_type.startswith('audio/') or len(response.content) > 1000:
                print(f"[DEBUG] TTS success: Audio received ({len(response.content)} bytes)")
                return response.content
            else:
                print(f"[DEBUG] TTS returned non-audio data: {content_type}")
                return None
        else:
            print(f"[DEBUG] TTS failed with status: {response.status_code}")
            return None
            
    except requests.exceptions.Timeout:
        print("[DEBUG] TTS generation timeout")
        return None
    except requests.exceptions.ConnectionError:
        print("[DEBUG] TTS generation connection error")
        return None
    except Exception as e:
        print(f"[DEBUG] TTS generation error: {e}")
        return None
    finally:
        # Stop the loader
        if loader:
            loader.stop()

def handle_say_command(bot, message, usage_tracker):
    """Handle /say command with usage tracking"""
    from utils import log_user_interaction, is_premium_user
    
    user_id = message.from_user.id
    log_user_interaction(message.from_user, "/say", "DM" if message.chat.type == "private" else "Group")
    
    # Check if user provided text
    text_input = message.text.strip()
    if len(text_input.split()) <= 1:
        bot.reply_to(message, """ğŸ¤ **Text-to-Speech Help**

**Usage:** `/say [text]`

**Examples:**
â€¢ `/say Hello, how are you today?`
â€¢ `/say Welcome to BrahMos AI!`
â€¢ `/say This is a test of speech synthesis`

**ğŸµ Available Voices:** alloy, echo, fable, onyx, nova, shimmer

**ğŸ’¡ Tip:** Keep text under 500 characters for best results!""", parse_mode="Markdown")
        return

    # Extract text (remove "/say ")
    text_to_speak = text_input[4:].strip()
    
    # Validate text length
    if len(text_to_speak) > 500:
        bot.reply_to(message, "âŒ **Text too long!** Please keep your text under 500 characters.", parse_mode="Markdown")
        return
    
    # Check usage limits for free users
    if not is_premium_user(user_id):
        if not usage_tracker.can_use_tts(user_id):
            bot.reply_to(message, """ğŸš« **Daily TTS Limit Reached**

You've used all 100 free TTS generations for today!

ğŸ’ **Upgrade to Premium for:**
â€¢ Unlimited TTS generations
â€¢ All voice options
â€¢ Priority processing

Contact @Rystrix to upgrade!""", parse_mode="Markdown")
            return
        
        # Warning when approaching limit
        remaining = usage_tracker.get_remaining_tts(user_id)
        if remaining <= 10:
            bot.reply_to(message, f"âš ï¸ **Usage Warning:** Only {remaining} TTS generations left today!", parse_mode="Markdown")

    try:
        # Generate TTS
        audio_data = generate_tts(text_to_speak, "nova", bot, message.chat.id)
        
        if audio_data:
            # Track usage for free users
            if not is_premium_user(user_id):
                usage_tracker.use_tts(user_id)
                remaining = usage_tracker.get_remaining_tts(user_id)
                remaining_text = f"\n\nğŸ“Š **Remaining today:** {remaining}/100"
            else:
                remaining_text = "\n\nğŸ’ **Premium User - Unlimited Access!**"
            
            caption = f"ğŸ¤ **Text-to-Speech**\n\n**Text:** `{text_to_speak}`\n**Voice:** Nova\n\nâœ¨ **Generated by BrahMos AI**{remaining_text}"
            
            # Send the audio
            bot.send_voice(
                message.chat.id,
                io.BytesIO(audio_data),
                caption=caption,
                parse_mode="Markdown",
                reply_to_message_id=message.message_id
            )
        else:
            bot.reply_to(message, "âŒ **TTS Generation Failed**\n\nSorry, I couldn't convert your text to speech. Please try again.", parse_mode="Markdown")
            
    except Exception as e:
        print(f"[DEBUG] TTS error: {e}")
        bot.reply_to(message, "ğŸ’¥ **Error:** Something went wrong while generating speech. Please try again!")

def handle_tts_input(bot, message, user_waiting_for_tts, usage_tracker):
    """Handle TTS text input when user is in TTS waiting mode"""
    from utils import is_premium_user
    
    user_id = message.from_user.id
    
    if user_id in user_waiting_for_tts:
        user_waiting_for_tts.remove(user_id)
        
        # Use the message text for TTS
        text_to_speak = message.text.strip()
        
        # Validate text length
        if len(text_to_speak) > 500:
            bot.reply_to(message, "âŒ **Text too long!** Please keep your text under 500 characters.", parse_mode="Markdown")
            return
        
        # Check usage limits for free users
        if not is_premium_user(user_id):
            if not usage_tracker.can_use_tts(user_id):
                bot.reply_to(message, """ğŸš« **Daily TTS Limit Reached**

You've used all 100 free TTS generations for today!

ğŸ’ **Upgrade to Premium for:**
â€¢ Unlimited TTS generations
â€¢ All voice options  
â€¢ Priority processing

Contact @Rystrix to upgrade!""", parse_mode="Markdown")
                return
        
        try:
            # Generate TTS
            audio_data = generate_tts(text_to_speak, "nova", bot, message.chat.id)
            
            if audio_data:
                # Track usage for free users
                if not is_premium_user(user_id):
                    usage_tracker.use_tts(user_id)
                    remaining = usage_tracker.get_remaining_tts(user_id)
                    remaining_text = f"\n\nğŸ“Š **Remaining today:** {remaining}/100"
                else:
                    remaining_text = "\n\nğŸ’ **Premium User - Unlimited Access!**"
                
                caption = f"ğŸ¤ **Text-to-Speech**\n\n**Text:** `{text_to_speak}`\n**Voice:** Nova\n\nâœ¨ **Generated by BrahMos AI**{remaining_text}"
                
                # Send the audio
                bot.send_voice(
                    message.chat.id,
                    io.BytesIO(audio_data),
                    caption=caption,
                    parse_mode="Markdown",
                    reply_to_message_id=message.message_id
                )
            else:
                bot.reply_to(message, "âŒ **TTS Generation Failed**\n\nSorry, I couldn't convert your text to speech. Please try again.", parse_mode="Markdown")
                
        except Exception as e:
            print(f"[DEBUG] TTS error: {e}")
            bot.reply_to(message, "ğŸ’¥ **Error:** Something went wrong while generating speech. Please try again!")